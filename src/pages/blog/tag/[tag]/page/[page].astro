---
import { Image } from 'astro:assets';
import { Icon } from 'astro-icon/components'
import { getCollection } from 'astro:content';
import BlogLayout from '@layouts/Blog.astro';
import Breadcrumbs from '@components/Breadcrumbs.astro';
import { calculateWordCountFromHtml, readingTime } from '@utils/postTools';
import Tags from '@components/Tags.astro';
import ListLd from '@components/seo/ListLd.astro';
import Categories from '@components/Categories.astro';
import RecentPosts from '@components/RecentPosts.astro';
import { pathToSlug } from '@utils/buildDocsSidebar';
import { SITE, TRANSLATIONS } from 'src/constants';
import { slugify } from 'scripts/slugify.mjs';

const PAGE_SIZE = SITE.postsPerPage;
const lang = SITE.defaultLanguage;

// export async function getStaticPaths() {
//   const lang = SITE.defaultLanguage;
//   const PAGE_SIZE = SITE.postsPerPage;

//   const entries = await getCollection('blog', ({ data }) => !data.draft && data.lang === lang);
//   const tagIndex = new Map<string, { label: string; count: number }>();

//   for (const e of entries) {
//     const tags = Array.isArray(e.data.tags) ? e.data.tags : [];
//     for (const raw of tags) {
//       const label = String(raw);
//       const slug = slugify(label);
//       const prev = tagIndex.get(slug);
//       if (prev) {
//         prev.count += 1;
//       } else {
//         tagIndex.set(slug, { label, count: 1 });
//       }
//     }
//   }

//   const paths: Array<{
//     params: { tag: string; page: string };
//     props: { tagSlug: string; tagName: string; page: number; totalPages: number; lang: string; pageSize: number; totalCount: number };
//   }> = [];

//   for (const [slug, meta] of tagIndex.entries()) {
//     const totalPages = Math.max(1, Math.ceil(meta.count / PAGE_SIZE));
//     for (let p = 2; p <= totalPages; p++) {
//       paths.push({
//         params: { tag: slug, page: String(p) },
//         props: {
//           tagSlug: slug,
//           tagName: meta.label,
//           page: p,
//           totalPages,
//           lang,
//           pageSize: PAGE_SIZE,
//           totalCount: meta.count,
//         },
//       });
//     }
//   }

//   return paths;
// }


const blogTitle = TRANSLATIONS[lang].blog;
const categoriesText = TRANSLATIONS[lang].tags;
const tagsText = TRANSLATIONS[lang].tags;
const pageText = TRANSLATIONS[lang].page;
const nextText = TRANSLATIONS[lang].next;
const prevText = TRANSLATIONS[lang].prev;

const { tag, page: pageParam } = Astro.params;
// const { tagName, page, totalPages } = Astro.props;

const page = pageParam ? Number(pageParam) || 1 : 1;

const entries = await getCollection('blog', ({ data }) => !data.draft && data.lang === lang);

const all = entries.filter(p => {
    const tags = Array.isArray(p.data.tags) ? p.data.tags : [];
    return tags.some(t => slugify(String(t)) === tag);
  }).sort((a, b) => (b.data.stickyWeight - a.data.stickyWeight)
              || (b.data.publishedAt.getTime() - a.data.publishedAt.getTime()));

const total = all.length;
const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));

let tagName = tag;
for (const e of entries) {
  const tags = Array.isArray(e.data.tags) ? e.data.tags : [];
  for (const raw of tags) {
    const label = String(raw);
    if (slugify(label) === tag) {
      tagName = label;
      break;
    }
  }
  if (tagName !== tag) break;
}

const start = (page - 1) * PAGE_SIZE;
const posts = all.slice(start, start + PAGE_SIZE);

const pageHref = (p: number) => p === 1 ? `/blog/tag/${tag}/` : `/blog/tag/${tag}/page/${p}/`;
---
<BlogLayout 
  title={`Tag: ${tagName} — ${pageText} ${page} | ${SITE.author}`} 
  description={ `Page ${page}` } 
  withSidebar={ true }
  showSearch={ false }
  prev={ page > 1 ? pageHref(page - 1) : undefined }
  next={ page < totalPages ? pageHref(page + 1) : undefined }
>
   <Breadcrumbs
    slot="breadcrumbs"
    items={[
      { label: blogTitle, href: '/blog', icon: 'tabler:library' },
      { label: tagName, href: `/blog/tag/${tag}/`, icon: 'tabler:tags' },
      { label: `${pageText} ${page}` },
    ]}
  />

  <h1 class="font-bold text-3xl">{ tagsText }: #{ tagName }</h1>

  <div class="gap-6 grid sm:grid-cols-2 lg:grid-cols-1" data-pagefind-ignore="all">
    <ListLd items={ posts.map(p => ({
      url: new URL(`/blog/${pathToSlug(p.id, lang)}/`, Astro.site).toString(),
      name: p.data.title,
      datePublished: (p.data.updatedAt ?? p.data.publishedAt).toISOString()
    }))} />

    { posts.length > 0 ?
      posts.map((post) => (
        <a
          href={ `/blog/${pathToSlug(post.id, lang)}/` }
          class="relative flex lg:flex-row flex-col gap-3 bg-white shadow-black shadow-xs hover:shadow-lg px-4 py-5 border-2 border-black rounded-md transition-all hover:-translate-y-1"
          aria-label={`Open category: ${post.data.title}` }
        >
          { post.data.stickyWeight > 0 ? (<Icon name="tabler:pin-filled" class="top-0 right-0 absolute size-5" />) : null }
          <div class="border rounded min-h-44 aspect-6/5 lg:aspect-2/1 overflow-hidden lg:basis-2/5">
            <Image
              class="bg-slate-300 w-full h-full object-cover"
              width={ 400 }
              height={ 300 } 
              src={ post.data.coverImage?.small ?? SITE.placeholder() }
              alt={ post.data.title }
            />
          </div>
         <div class="flex flex-col lg:basis-3/5">
          <h2 class="mb-2 font-semibold text-lg leading-tight">{ post.data.title }</h3>
          <p class="mb-2 text-sm line-clamp-3">
            { post.data.description }
          </p>
          <!-- Meta -->
          <div class="mt-auto">
            <p class="space-x-1 text-slate-500 text-xs">
              <span class="inline-flex items-start gap-1"><Icon name="tabler:calendar-week-filled" class="size-4" /> { (post.data.updatedAt ?? post.data.publishedAt).toLocaleDateString(post.data.lang, { timeZone: 'UTC' }) }</span>
              <span class="inline-flex items-start gap-1"><Icon name="tabler:hourglass-high" class="size-4" /> { readingTime(calculateWordCountFromHtml(post.body)) }</span>
            </p>
            <p class="space-x-1 text-slate-500 text-xs">
              <span class="inline-flex items-start gap-1"><Icon name="tabler:category" class="size-4" /> { post.data.category }</span>
              <span class="inline-flex items-start gap-1"><Icon name="tabler:tags" class="size-4" /> { post.data.tags.map(tag => `#${tag}`).slice(0, 3).join(' ') }</span>              
            </p>
          </div>
         </div>
        </a>
      )) :
      <div class="text-4xl xl:text-8xl text-center text-nowrap" set:text="¯\_(ツ)_/¯"></div>
    }
  </div>

  <nav class="flex justify-between items-center my-8" aria-label="Pagination">
    <div>
      { page > 1 && (
        <a class="underline" href={ pageHref(page - 1) }>← { prevText }</a>
      ) }
    </div>
    <span class="opacity-70 text-sm">{ pageText } { page } / { totalPages }</span>
    <div>
      { page < totalPages && (
        <a class="underline" href={ pageHref(page + 1) }>{ nextText } →</a>
      ) }
    </div>
  </nav>

  <!-- sidebar slots -->  
  <RecentPosts slot="recent" tag={ tagName } />
  <Categories slot="categories" title={ categoriesText } />
  <Tags slot="tags" title={ tagsText } currentTag={ tagName } />
<!-- <div slot="ad-sidebar"></div>
  <div slot="ad-top"></div> -->
</BlogLayout>
